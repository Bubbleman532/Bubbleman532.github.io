{"version":3,"sources":["webpack:///webpack/bootstrap f9d2797538cf557e8b7a","webpack:///./src/TMViz.js","webpack:///./src/TuringMachine.js","webpack:///./src/tape/TapeViz.js","webpack:///./src/tape/Tape.js","webpack:///external \"_\"","webpack:///external \"d3\"","webpack:///./src/tape/tape.css","webpack:///external \"jsyaml\"","webpack:///external \"ace\"","webpack:///./src/util.js","webpack:///./src/storage.js","webpack:///./src/state-diagram/StateGraph.js","webpack:///external \"lodash\"","webpack:///./src/state-diagram/StateViz.js","webpack:///./src/state-diagram/StateViz.css","webpack:///./src/parser.js","webpack:///./src/watch.js"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wEAAgE,WAAW;AAC3E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,WAAW;AACvB,aAAY,kBAAkB;AAC9B,aAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,eAAe;AAC5B,aAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAgC;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8DAA6D,OAAO;AACpE;AACA,YAAW,eAAe;AAC1B;AACA,YAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;;;;;;;;;;ACvPA;AACA;AACA;AACA,YAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,0BAAyB,aAAa;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,sDAAsD,EAAE;AAC9E;AACA,IAAG;AACH;AACA,uBAAsB,qCAAqC,EAAE;AAC7D;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,2CAA0C;AAC1C,0CAAyC;AACzC;AACA;AACA;AACA;AACA,WAAU,uBAAuB,YAAY,EAAE,EAAE;AACjD,WAAU,uBAAuB,YAAY,EAAE;AAC/C,EAAC;AACD,+BAA8B,2CAA2C;;AAEzE;AACA;AACA;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,8BAA6B;AAC7B;AACA,2BAA0B,UAAU,EAAE;AACtC,cAAa,wCAAwC;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,UAAU,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACjOA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,8CAA6C;AAC7C,6DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;;;;AC3EA,oB;;;;;;;;;ACAA,qB;;;;;;;;;ACAA,0D;;;;;;;;;ACAA,yB;;;;;;;;;ACAA,sB;;;;;;;;;ACAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mEAAkE;;;AAGlE;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;ACzEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,mBAAkB,gCAAgC,EAAE;AACpD,wBAAuB,6DAA6D,EAAE;AACtF,8BAA6B,UAAU,iDAAiD,EAAE;AAC1F,mCAAkC,wBAAwB,EAAE;AAC5D,iCAAgC,iBAAiB,EAAE;AACnD,yBAAwB,UAAU;AAClC,IAAG;AACH,EAAC;;AAED;AACA;;AAEA;AACA;AACA,oBAAmB,mCAAmC;AACtD,oBAAmB,cAAc;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;;;;;;;;;;ACnEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;;AAEP;AACA,MAAK;;AAEL,IAAG;;AAEH,WAAU;AACV;;AAEA;AACA,UAAS,YAAY,gBAAgB,yBAAyB;AAC9D;AACA,uBAAsB,gBAAgB,6BAA6B;AACnE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,eAAc,uBAAuB;AACrC,eAAc;AACd,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,EAAE,wBAAwB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;ACzKA,yB;;;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sCAAqC,sBAAsB,EAAE;AAC7D;;AAEA;AACA,kCAAiC,WAAW,EAAE;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC,iBAAiB,EAAE;AACpD;;AAEA;AACA;AACA,mBAAkB,YAAY;AAC9B,uBAAsB,cAAc;AACpC;AACA;;AAEA;AACA,wBAAuB,kCAAkC;;AAEzD;AACA;AACA;AACA,kCAAiC,cAAc,EAAE;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,WAAU;AACV,UAAS;AACT,eAAc;AACd,EAAC;;AAED;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,aAAa;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAU;AACV;AACA;;AAEA,uBAAsB,UAAU;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA,uBAAsB;AACtB,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,YAAY;AACxB,aAAY,wBAAwB;AACpC;AACA;AACA,aAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,oBAAmB;AACnB;AACA,kDAAiD;AACjD;;AAEA;AACA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB;AACnB,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,WAAU;AACV,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,sDAAqD;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB,oCAAmC;AACnC,OAAM;AACN,6BAA4B;AAC5B,2CAA0C;AAC1C,OAAM;AACN,8BAA6B;AAC7B,+CAA8C;AAC9C,yBAAwB;AACxB,OAAM;AACN,0CAAyC;AACzC,sDAAqD;AACrD,yBAAwB;AACxB,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;;AAEP;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,yDAAwD,qCAAqC;AAC7F;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA,KAAI,mBAAmB;AACvB;;AAEA;AACA,sBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,qBAAoB,0CAA0C,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;;;;;;;;;;ACnlCA,uE;;;;;;;;;ACAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,gBAAgB,EAAE;AAC3C,oBAAmB,gCAAgC;AACnD;AACA,IAAG;AACH;AACA,EAAC;;AAED,4BAA2B,iBAAiB,sBAAsB;AAClE,mBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,MAAK;AACL,wEAAuE,EAAE;AACzE,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,0DAA0D;AAC/D;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK,oDAAoD;AACzD;AACA;AACA;AACA,QAAO;AACP,wGAAuG;AACvG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,kCAAiC,UAAU,UAAU;AACrD;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA,mBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,0GAAyG;AACzG;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA,sCAAqC;AACrC;AACA,kCAAiC,yCAAyC;AAC1E,mBAAkB,kBAAkB,EAAE;AACtC;;AAEA;AACA;AACA,gDAA+C;AAC/C,gHAA+G;AAC/G;AACA;AACA;;AAEA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,gDAA+C,UAAU,gBAAgB,uBAAuB,UAAU;AAC1G;AACA,IAAG;AACH;;AAEA,+BAA8B,uBAAuB;AACrD,gCAA+B,wBAAwB;;AAEvD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,iDAAgD,MAAM;AACtD,mCAAkC,sBAAsB;AACxD;AACA,MAAK;AACL,gFAA+E;AAC/E;;AAEA,sBAAqB,wBAAwB,IAAI;AACjD;AACA;AACA;AACA,qBAAoB,8CAA8C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,UAAS;AACT;AACA,4DAA2D;AAC3D;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK,kFAAkF;AACvF;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,OAAO;AACnB;AACA;AACA;AACA,aAAY,UAAU;AACtB,aAAY,UAAU;AACtB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA,KAAI,YAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,uBAAuB;AACpC;AACA;;AAEA;AACA;AACA;AACA","file":"TMViz.bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp_name_\"];\n \twindow[\"webpackJsonp_name_\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({\"1\":\"main\"}[chunkId]||chunkId) + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f9d2797538cf557e8b7a","'use strict';\r\n/**\r\n * Turing machine visualization component.\r\n *\r\n * • Adds running and reset on top of the base Turing machine.\r\n * • Displays an animated state diagram and tape diagram.\r\n * Does not include UI elements for controlling the machine.\r\n *\r\n * @module\r\n */\r\n\r\nvar TuringMachine = require('./TuringMachine').TuringMachine,\r\n  TapeViz = require('./tape/TapeViz'),\r\n  StateGraph = require('./state-diagram/StateGraph'),\r\n  StateViz = require('./state-diagram/StateViz'),\r\n  watchInit = require('./watch').watchInit,\r\n  d3 = require('d3');\r\n\r\n/**\r\n * Create an animated transition function.\r\n * @param  {StateGraph} graph\r\n * @param  {LayoutEdge -> any} animationCallback\r\n * @return {(string, string) -> Instruction} Created transition function.\r\n */\r\nfunction animatedTransition(graph, animationCallback) {\r\n  return function (state, symbol) {\r\n    var tuple = graph.getInstructionAndEdge(state, symbol);\r\n    if (tuple == null) {\r\n      return null;\r\n    }\r\n\r\n    animationCallback(tuple.edge);\r\n    return tuple.instruction;\r\n  };\r\n}\r\n\r\n/**\r\n * Default edge animation callback.\r\n * @param  {{domNode: Node}} edge\r\n * @return {D3Transition} The animation. Use this for transition chaining.\r\n */\r\nfunction pulseEdge(edge) {\r\n  var edgepath = d3.select(edge.domNode);\r\n  return edgepath\r\n    .classed('active-edge', true)\r\n    .transition()\r\n    .style('stroke-width', '3px')\r\n    .transition()\r\n    .style('stroke-width', '1px')\r\n    .transition()\r\n    .duration(0)\r\n    .each('start', /* @this edge */ function () {\r\n      d3.select(this).classed('active-edge', false);\r\n    })\r\n    .style('stroke', null)\r\n    .style('stroke-width', null);\r\n}\r\n\r\nfunction addTape(div, spec) {\r\n  //build the controls div using d3 code\r\n  var container = div.append('div')\r\n    .attr('id', 'tape-edit-controls')\r\n    .attr('style', 'display: none')\r\n    .classed('edit-controls', true);\r\n\r\n  var inputDiv = container.append('div')\r\n    .append('label')\r\n    .attr('for', 'tape-edit-input')\r\n    .attr('style', 'font-weight: bold')\r\n    .text('Input:');\r\n\r\n  inputDiv.append('input')\r\n    .attr('id', 'tape-edit-input')\r\n    .attr('type', 'text')\r\n    .attr('style', 'width: 100px; text-align: center');\r\n\r\n  var blankDiv = container.append('div')\r\n    .append('label')\r\n    .attr('for', 'tape-edit-blank')\r\n    .attr('style', 'font-weight: bold')\r\n    .text('Blank:');\r\n\r\n  blankDiv.append('input')\r\n    .attr('id', 'tape-edit-blank')\r\n    .attr('type', 'text')\r\n    .attr('maxlength', '1')\r\n    .attr('style', 'width: 30px; text-align: center');\r\n\r\n  container.append('button')\r\n    .attr('id', 'tape-edit-set')\r\n    .classed('btn btn-primary', true)\r\n    .text('Set');\r\n\r\n  return new TapeViz(div.append('svg').attr('class', 'tm-tape'), 9,\r\n    spec.blank, spec.input ? String(spec.input).split('') : []);\r\n}\r\n\r\n/**\r\n * Construct a new state and tape visualization inside a &lt;div&gt;.\r\n * @constructor\r\n * @param {HTMLDivElement} div        div to take over and use.\r\n * @param                  spec       machine specification\r\n * @param {PositionTable} [posTable]  position table for the state nodes\r\n */\r\nfunction TMViz(div, spec, posTable) {\r\n  div = d3.select(div);\r\n  var graph = new StateGraph(spec.table);\r\n  this.stateviz = new StateViz(\r\n    div,\r\n    graph.getVertexMap(),\r\n    graph.getEdges()\r\n  );\r\n  if (posTable != undefined) {\r\n    this.positionTable = posTable;\r\n  }\r\n\r\n  this.edgeAnimation = pulseEdge;\r\n  this.stepInterval = 100;\r\n\r\n  var self = this;\r\n\r\n  // We hook into the animation callback to know when to start the next step (when running).\r\n  function animateAndContinue(edge) {\r\n    var transition = self.edgeAnimation(edge);\r\n    if (self.isRunning) {\r\n      transition.transition().duration(self.stepInterval).each('end', function () {\r\n        // stop if machine was paused during the animation\r\n        if (self.isRunning) {\r\n          self.step();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  this.machine = new TuringMachine(\r\n    animatedTransition(graph, animateAndContinue),\r\n    spec.startState,\r\n    addTape(div, spec)\r\n  );\r\n  // intercept and animate when the state is set\r\n  watchInit(this.machine, 'state', function (prop, oldstate, newstate) {\r\n    d3.select(graph.getVertex(oldstate).domNode).classed('current-state', false);\r\n    d3.select(graph.getVertex(newstate).domNode).classed('current-state', true);\r\n    return newstate;\r\n  });\r\n\r\n  // Sidenote: each \"Step\" click evaluates the transition function once.\r\n  // Therefore, detecting halting always requires its own step (for consistency).\r\n  this.isHalted = false;\r\n\r\n  var isRunning = false;\r\n  /**\r\n   * Set isRunning to true to run the machine, and false to stop it.\r\n   */\r\n  Object.defineProperty(this, 'isRunning', {\r\n    configurable: true,\r\n    get: function () {\r\n      return isRunning;\r\n    },\r\n    set: function (value) {\r\n      if (isRunning !== value) {\r\n        isRunning = value;\r\n        if (isRunning) {\r\n          this.step();\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  this.resetRunLog();\r\n\r\n  this.__parentDiv = div;\r\n  this.__spec = spec;\r\n  this.__graph = graph;\r\n  this.__step = 1;\r\n}\r\n\r\nTMViz.prototype.resetRunLog = function () {\r\n    var runLogTable = d3.select(\"#runLogTable\");\r\n    runLogTable.selectAll(\"tbody\").remove();\r\n    var newRow = runLogTable.append(\"tbody\").append(\"tr\");\r\n    newRow.append(\"td\").text(\"Step\");\r\n    newRow.append(\"td\").text(\"Transition\");\r\n    newRow.append(\"td\").text(\"Tape\");\r\n    newRow.append(\"td\").text(\"New State\");\r\n\r\n    var secondRow = runLogTable.append(\"tbody\").append(\"tr\");\r\n    secondRow.append(\"td\").text(\"\");\r\n    secondRow.append(\"td\").text(\"\");\r\n    secondRow.append(\"td\").text(this.machine.tape.toString());\r\n    secondRow.append(\"td\").text(this.machine.state);\r\n}\r\n\r\n/**\r\n * Step the machine immediately and interrupt any animations.\r\n */\r\nTMViz.prototype.step = function () {\r\n  var prevState = this.machine.state;\r\n  var prevSymbol = this.machine.tape.read();\r\n  var a = this.machine.extendedStep();\r\n\r\n  if (a === null) {\r\n    this.isRunning = false;\r\n    this.isHalted = true;\r\n    return;\r\n  }\r\n\r\n  var vertex = this.__graph.getVertex(prevState);\r\n  var transitions = vertex.transitions;\r\n  var transition = transitions[prevSymbol];\r\n  var edge = transition.edge;\r\n  var label = edge.labelsForSymbol[prevSymbol];\r\n  // if (label !== undefined) {\r\n  //   console.log(label);\r\n  // }\r\n  var runLogTable = d3.select(\"#runLogTable\");\r\n  var newRow = runLogTable.append(\"tbody\").append(\"tr\");\r\n  newRow.append(\"td\").text(this.__step);\r\n  newRow.append(\"td\").text(label);\r\n  newRow.append(\"td\").text(this.machine.tape.toString());\r\n  newRow.append(\"td\").text(this.machine.state);\r\n  this.__step++;\r\n};\r\n\r\n/**\r\n * Reset the Turing machine to its starting configuration.\r\n */\r\n\r\nTMViz.prototype.reset = function () {\r\n  this.isRunning = false;\r\n  this.isHalted = false;\r\n  this.machine.state = this.__spec.startState;\r\n  this.machine.tape.domNode.remove();\r\n  this.machine.tape = addTape(this.__parentDiv, this.__spec);\r\n  this.resetRunLog();\r\n  this.__step = 1;\r\n};\r\n\r\nObject.defineProperty(TMViz.prototype, 'positionTable', {\r\n  get: function () {\r\n    return this.stateviz.positionTable;\r\n  },\r\n  set: function (posTable) {\r\n    this.stateviz.positionTable = posTable;\r\n  }\r\n});\r\n\r\nmodule.exports = TMViz;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TMViz.js\n// module id = 1\n// module chunks = 0","'use strict';\r\n/**\r\n * Construct a Turing machine.\r\n * @param {(state, symbol) -> ?{state: state, symbol: symbol, move: direction}}\r\n *   transition\r\n *   A transition function that, given *only* the current state and symbol,\r\n *   returns an object with the following properties: symbol, move, and state.\r\n *   Returning null/undefined halts the machine (no transition defined).\r\n * @param {state} startState  The state to start in.\r\n * @param         tape        The tape to use.\r\n */\r\nfunction TuringMachine(transition, startState, tape) {\r\n  this.transition = transition;\r\n  this.state = startState;\r\n  this.tape = tape;\r\n}\r\n\r\nTuringMachine.prototype.toString = function () {\r\n  return String(this.state) + '\\n' + String(this.tape);\r\n};\r\n\r\n/**\r\n * Step to the next configuration according to the transition function.\r\n * @return {boolean} true if successful (the transition is defined),\r\n *   false otherwise (machine halted)\r\n */\r\nTuringMachine.prototype.extendedStep = function () {\r\n  var instruct = this.nextInstruction;\r\n  if (instruct == null) { return null; }\r\n\r\n  this.tape.write(instruct.symbol);\r\n  move(this.tape, instruct.move);\r\n  this.state = instruct.state;\r\n\r\n  return instruct;\r\n};\r\n\r\nTuringMachine.prototype.step = function () {\r\n  return this.extendedStep() !== null;\r\n}\r\n\r\nObject.defineProperties(TuringMachine.prototype, {\r\n  nextInstruction: {\r\n    get: function () { return this.transition(this.state, this.tape.read()); },\r\n    enumerable: true\r\n  },\r\n  isHalted: {\r\n    get: function () { return this.nextInstruction == null; },\r\n    enumerable: true\r\n  }\r\n});\r\n\r\n// Allows for both notational conventions of moving the head or moving the tape\r\nfunction move(tape, direction) {\r\n  switch (direction) {\r\n    case MoveHead.right: tape.headRight(); break;\r\n    case MoveHead.left:  tape.headLeft();  break;\r\n    default: throw new TypeError('not a valid tape movement: ' + String(direction));\r\n  }\r\n}\r\nvar MoveHead = Object.freeze({\r\n  left:  {toString: function () { return 'L'; } },\r\n  right: {toString: function () { return 'R'; } }\r\n});\r\nvar MoveTape = Object.freeze({left: MoveHead.right, right: MoveHead.left});\r\n\r\nexports.MoveHead = MoveHead;\r\nexports.MoveTape = MoveTape;\r\nexports.TuringMachine = TuringMachine;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TuringMachine.js\n// module id = 2\n// module chunks = 0","'use strict';\r\nvar Tape = require('./Tape.js'),\r\n    d3   = require('d3');\r\nrequire('./tape.css');\r\nvar jsyaml = require('js-yaml');\r\nvar ace = require('ace-builds/src-min-noconflict');\r\nconst util = require('../util');\r\nvar KeyValueStorage = require('../storage').KeyValueStorage;\r\n\r\nvar nodeEditControls = window.document.getElementById('node-edit-controls');\r\nvar transitionEditControls = window.document.getElementById('transition-edit-controls');\r\nvar nodeLabel = window.document.getElementById('nodeLabel');\r\nvar startState = window.document.getElementById('startState');\r\nvar read = window.document.getElementById('read');\r\nvar write = window.document.getElementById('write');\r\nvar moveL = window.document.getElementById('moveL');\r\nvar moveR = window.document.getElementById('moveR');\r\nvar deleteNode = window.document.getElementById('deleteNode');\r\nvar deleteLink = window.document.getElementById('deleteLink');\r\nvar source = ace.edit(document.getElementById('editor-container'));\r\nvar cellWidth = 50;\r\nvar cellHeight = 50;\r\n\r\nfunction initTapeCells(selection) {\r\n  selection.attr('class', 'tape-cell');\r\n  selection.append('rect')\r\n      // the box outline is purely visual, so remove its data binding\r\n      .datum(null)\r\n      .attr({'width': cellWidth,\r\n        'height': cellHeight});\r\n  selection.append('text')\r\n      .text(function (d) { return d; })\r\n      .attr({'x': cellWidth/2, 'y': cellHeight/2 + 8});\r\n  return selection;\r\n}\r\n\r\nfunction positionCells(selection, offset) {\r\n  offset = (offset == null) ? 0 : offset;\r\n  selection.attr('transform', function (d, i) {\r\n    return 'translate(' + (-cellWidth+10 + cellWidth*(i+offset)) + ')';\r\n  });\r\n  return selection;\r\n}\r\n\r\nfunction repositionWrapper(wrapper) {\r\n  wrapper.attr('transform', 'translate(0 10)')\r\n    .transition()\r\n      .duration(0)\r\n    .select('.exiting')\r\n      .remove();\r\n}\r\n\r\n// Tape visualization centered around the tape head.\r\nfunction TapeViz(svg, lookaround, blank, input) {\r\n  Tape.call(this, blank, input);\r\n\r\n  Object.defineProperty(this, 'lookaround', {\r\n    value: lookaround,\r\n    writable: false,\r\n    enumerable: true\r\n  });\r\n  Object.defineProperty(this, 'domNode', {\r\n    value: svg,\r\n    writable: false,\r\n    enumerable: true\r\n  });\r\n\r\n  // width is before + head + after, trimming 2 off to show cut-off tape ends\r\n  var width  = cellWidth * (lookaround+1+lookaround-2) + 2*10;\r\n  var height = cellHeight + 2*10;\r\n  svg.attr({\r\n    'width': '95%',\r\n    'viewBox': [0, 0, width, height].join(' ')\r\n  });\r\n\r\n  this.wrapper = svg.append('g')\r\n      .attr('class', 'wrapper')\r\n      .call(repositionWrapper);\r\n\r\n  svg.append('rect')\r\n      .attr({'id': 'tape-head',\r\n        'width': (1+1/5) * cellWidth,\r\n        'height': (1+1/5) * cellHeight,\r\n        'x': -cellWidth+10/2 + cellWidth*lookaround,\r\n        'y': 10/2\r\n      });\r\n\r\n  this.wrapper.selectAll('.tape-cell')\r\n      .data(this.readRange(-lookaround, lookaround))\r\n    .enter()\r\n    .append('g')\r\n      .call(initTapeCells)\r\n      .call(positionCells)\r\n  ;\r\n\r\n  //when the tape is clicked, show the edit controls\r\n  svg.on('dblclick', function () {\r\n    //disable all the form fields - messy...\r\n    nodeLabel.disabled = true;\r\n    nodeLabel.value = '';\r\n    startState.disabled = true;\r\n    startState.checked = false;\r\n    deleteNode.disabled = true;\r\n    read.disabled = true;\r\n    read.value = '';\r\n    write.disabled = true;\r\n    write.value = '';\r\n    moveL.disabled = true;\r\n    moveR.disabled = true;\r\n    deleteLink.disabled = true;\r\n    transitionEditControls.setAttribute(\"style\", \"display: none\");\r\n    nodeEditControls.setAttribute(\"style\", \"display: flex\");\r\n    //grab the machine\r\n    var machine = jsyaml.safeLoad(source.getValue());\r\n    var controlsDiv = window.document.getElementById('tape-edit-controls');\r\n    controlsDiv.setAttribute(\"style\", \"display: flex\");\r\n    var controlsInput = window.document.getElementById('tape-edit-input');\r\n    controlsInput.value = machine['input'];\r\n    var controlsBlank = window.document.getElementById('tape-edit-blank');\r\n    controlsBlank.value = machine['blank'];\r\n    var controlsSet = window.document.getElementById('tape-edit-set');\r\n    controlsSet.addEventListener('click', function () {\r\n      //change input\r\n      machine['input'] = controlsInput.value;\r\n      //change every read symbol that matches the blank symbol\r\n      for (var node in machine.table) {\r\n        for (var readSymbols in machine.table[node]){\r\n          var newRead = [];\r\n          var splitRead = readSymbols.split(\",\");\r\n          for (var symbol of splitRead) {\r\n            if (symbol === machine['blank']) symbol = controlsBlank.value;\r\n            newRead.push(symbol);\r\n          }\r\n          if (!(readSymbols === newRead.join())){\r\n             machine.table[node][newRead] = machine.table[node][readSymbols];\r\n             delete machine.table[node][readSymbols];\r\n          }\r\n          if (machine.table[node][newRead].hasOwnProperty(\"write\")) {\r\n            if (machine.table[node][newRead]['write'] === machine['blank'])\r\n              machine.table[node][newRead]['write'] = controlsBlank.value\r\n          }\r\n        }\r\n      }\r\n      //finally change blank symbol\r\n      machine['blank'] = controlsBlank.value;\r\n      //we're finished here\r\n      source.setValue(jsyaml.safeDump(machine));\r\n      KeyValueStorage.write('TMReload', 'tape changed');\r\n    })\r\n  });\r\n}\r\n\r\nTapeViz.prototype = Object.create(Tape.prototype);\r\nTapeViz.prototype.constructor = TapeViz;\r\n\r\n// IDEA: chain headLeft/Right to wait for write()?\r\nTapeViz.prototype.write = function (symbol) {\r\n  // don't animate if symbol stays the same\r\n  if (Tape.prototype.read.call(this) === symbol) {\r\n    return;\r\n  }\r\n  Tape.prototype.write.call(this, symbol);\r\n\r\n  // remove leftover .exiting in case animation was interrupted\r\n  this.wrapper.selectAll('.exiting').remove();\r\n\r\n  d3.select(this.wrapper[0][0].childNodes[this.lookaround])\r\n      .datum(symbol)\r\n    .select('text')\r\n      .attr('fill-opacity', '1')\r\n      .attr('stroke-opacity', '1')\r\n    .transition()\r\n      .attr('fill-opacity', '0.4')\r\n      .attr('stroke-opacity', '0.1')\r\n    .transition()\r\n      .text(function (d) { return d; })\r\n      .attr('fill-opacity', '1')\r\n      .attr('stroke-opacity', '1')\r\n    .transition()\r\n      .duration(0)\r\n      .attr('fill-opacity', null)\r\n      .attr('stroke-opacity', null)\r\n    ;\r\n};\r\n\r\nfunction moveHead(wrapper, enter, exit, wOffset, cOffset) {\r\n  // add to one end\r\n  enter.call(initTapeCells);\r\n  // remove from the other end\r\n  exit.classed('exiting', true);\r\n  // translate cells forward, and the wrapper backwards\r\n  wrapper.selectAll('.tape-cell')\r\n      .call(positionCells, cOffset);\r\n  wrapper\r\n      .attr('transform', 'translate(' + (wOffset*cellWidth).toString() + ' 10)')\r\n    // animate wrapper returning to neutral position\r\n    .transition()\r\n      .call(repositionWrapper);\r\n}\r\n\r\nTapeViz.prototype.headRight = function () {\r\n  Tape.prototype.headRight.call(this);\r\n  // remove leftover .exiting in case animation was interrupted.\r\n  // Important: call-by-value evaluates the selection argument(s) of 'moveHead' before\r\n  // before entering the function, so exiting nodes have to be removed beforehand.\r\n  this.wrapper.selectAll('.exiting').remove();\r\n  moveHead(this.wrapper,\r\n    // add to right end\r\n    this.wrapper.append('g')\r\n        .datum(this.readOffset(this.lookaround)),\r\n    // remove from left end\r\n    this.wrapper.select('.tape-cell'),\r\n    1, -1);\r\n};\r\n\r\nTapeViz.prototype.headLeft = function () {\r\n  Tape.prototype.headLeft.call(this);\r\n  this.wrapper.selectAll('.exiting').remove();\r\n  moveHead(this.wrapper,\r\n    this.wrapper.insert('g', ':first-child')\r\n        .datum(this.readOffset(-this.lookaround)),\r\n    this.wrapper.select('.wrapper > .tape-cell:last-of-type'),\r\n    -1, 0);\r\n};\r\n\r\nmodule.exports = TapeViz;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tape/TapeViz.js\n// module id = 3\n// module chunks = 0","'use strict';\r\n\r\nvar _ = require('lodash/fp');\r\n\r\n// Bidirectional infinite tape\r\nfunction Tape(blank, input) {\r\n  Object.defineProperty(this, 'blank', {\r\n    value: blank,\r\n    writable: false,\r\n    enumerable: true\r\n  });\r\n  // zipper data structure\r\n  // INVARIANTS: tape.before can be empty, tape.after must be nonempty.\r\n  // before: cells before the head (in order; left to right).\r\n  // after:  cells after and including the head (in reverse; right to left).\r\n  this.tape = {\r\n    before: [],\r\n    after: (input == null || input.length == 0) ? [blank] : input.slice().reverse(),\r\n    toString: function () {\r\n      return this.before.join(' ') + ' [' + this.after.slice(-1) + '] ' + this.after.slice().reverse().slice(1).join(' ');\r\n    }\r\n  };\r\n}\r\n\r\n// Read the value at the tape head.\r\nTape.prototype.read = function () {\r\n  return _.last(this.tape.after);\r\n};\r\nTape.prototype.write = function (symbol) {\r\n  this.tape.after[this.tape.after.length - 1] = symbol;\r\n};\r\n\r\nTape.prototype.headRight = function () {\r\n  var before = this.tape.before,\r\n      after = this.tape.after;\r\n  before.push(after.pop());\r\n  if (_.isEmpty(after)) {\r\n    after.push(this.blank);\r\n  }\r\n};\r\nTape.prototype.headLeft = function () {\r\n  var before = this.tape.before,\r\n      after = this.tape.after;\r\n  if (_.isEmpty(before)) {\r\n    before.push(this.blank);\r\n  }\r\n  after.push(before.pop());\r\n};\r\n\r\nTape.prototype.toString = function () {\r\n  return this.tape.toString();\r\n};\r\n\r\n// for tape visualization. not part of TM definition.\r\n// Read the value at an offset from the tape head.\r\n// 0 is the tape head. + is to the right, - to the left.\r\nTape.prototype.readOffset = function (i) {\r\n  var tape = this.tape;\r\n  if (i >= 0) {\r\n    // right side: offset [0..length-1] ↦ array index [length-1..0]\r\n    return (i <= tape.after.length - 1) ? tape.after[tape.after.length - 1 - i] : this.blank;\r\n  } else {\r\n    // left side: offset [-1..-length] ↦ array index [length-1..0]\r\n    return (i >= -tape.before.length) ? tape.before[tape.before.length + i] : this.blank;\r\n  }\r\n};\r\n\r\n// for tape visualization.\r\n// Read the values from an offset range (inclusive of start and end).\r\nTape.prototype.readRange = function (start, end) {\r\n  return _.range(start, end+1).map(function (i) {\r\n    return this.readOffset(i);\r\n  }, this);\r\n};\r\n\r\nmodule.exports = Tape;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tape/Tape.js\n// module id = 4\n// module chunks = 0","module.exports = _;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"_\"\n// module id = 5\n// module chunks = 0","module.exports = d3;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3\"\n// module id = 6\n// module chunks = 0","module.exports = __webpack_public_path__ + \"tape/tape.css\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tape/tape.css\n// module id = 7\n// module chunks = 0","module.exports = jsyaml;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jsyaml\"\n// module id = 8\n// module chunks = 0","module.exports = ace;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ace\"\n// module id = 9\n// module chunks = 0","'use strict';\n// misc. utilities\n\n//////////////////////////////////\n// Utilities for null/undefined //\n//////////////////////////////////\n\n// Assert non-null.\n// Return the value if it is not null or undefined; otherwise, throw an error.\nfunction nonNull(value) {\n  if (value == null) {\n    throw new Error('expected a non-null defined value, but got: ' + String(value));\n  }\n  return value;\n}\n\n// Null coalescing: iff the first argument is null or undefined, return the second.\nfunction coalesce(a, b) {\n  return (a != null) ? a : b;\n}\n\n// Apply a function to a value if non-null, otherwise return the value.\n// (Monadic bind for maybe (option) type.)\n// ((a -> b), ?a) -> ?b\nfunction applyMaybe(f, x) {\n  return (x != null) ? f(x) : x;\n}\n\n// Returns the first function result that is not null or undefined.\n// Otherwise, returns undefined.\n// ((a -> ?b), [a]) -> ?b\nfunction getFirst(f, xs) {\n  for (var i = 0; i < xs.length; ++i) {\n    var val = f(xs[i]);\n    if (val != null) {\n      return val;\n    }\n  }\n}\n\n/////////\n// DOM //\n/////////\n\n/* global document */\n\n/**\n * Concat an array of DOM Nodes into a DocumentFragment.\n * @param  {[Node]} array\n * @return {DocumentFragment}\n */\nfunction toDocFragment(array) {\n  var result = document.createDocumentFragment();\n  array.forEach(result.appendChild.bind(result));\n  return result;\n}\n\n///////////////////////\n// IE/Edge detection //\n///////////////////////\n\n// http://stackoverflow.com/a/9851769\nvar isBrowserIEorEdge = /*@cc_on!@*/false\n  || Boolean(document.documentMode) || Boolean(window.StyleMedia); // eslint-disable-line\n\n\nexports.nonNull = nonNull;\nexports.coalesce = coalesce;\nexports.applyMaybe = applyMaybe;\nexports.getFirst = getFirst;\n\nexports.toDocFragment = toDocFragment;\n\nexports.isBrowserIEorEdge = isBrowserIEorEdge;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nvar isBrowserIEorEdge = require('./util').isBrowserIEorEdge;\n/* global localStorage:false, window:false */\n\n///////////////////////\n// Key-Value Storage //\n///////////////////////\n\nvar canUseLocalStorage = (function () {\n  // from modernizr v3.3.1 (modernizr.com)\n  var mod = 'modernizr';\n  try {\n    localStorage.setItem(mod, mod);\n    localStorage.removeItem(mod);\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// RAM-only fallback\nvar RAMStorage = (function () {\n  var obj = {};\n  return Object.freeze({\n    get length() { return Object.keys(obj).length; },\n    key: function (n) { return (n in Object.keys(obj)) ? Object.keys(obj)[n] : null; },\n    getItem: function (key) { return {}.hasOwnProperty.call(obj, key) ? obj[key] : null; },\n    setItem: function (key, val) { obj[key] = String(val); },\n    removeItem: function (key) { delete obj[key]; },\n    clear: function () { obj = {}; }\n  });\n})();\n\nvar KeyValueStorage = (function () {\n  var s = canUseLocalStorage ? localStorage : RAMStorage;\n\n  // workaround IE/Edge firing events on its own window\n  var fromOwnWindow = isBrowserIEorEdge\n    ? function () { return window.document.hasFocus(); }\n    : function () { return false; };\n\n  return {\n    read  : s.getItem.bind(s),\n    write : s.setItem.bind(s),\n    remove: s.removeItem.bind(s),\n    // Registers a listener for StorageEvents from other tabs/windows.\n    addStorageListener: canUseLocalStorage\n      ? function (listener) {\n        window.addEventListener('storage', function (e) {\n          if (fromOwnWindow()) {\n            return;\n          }\n          if (e.storageArea === localStorage) {\n            listener(e);\n          }\n        });\n      }\n      : function () {},\n    removeStorageListener: canUseLocalStorage\n      ? window.removeEventListener.bind(window, 'storage')\n      : function () {}\n  };\n})();\n\n\nexports.canUseLocalStorage = canUseLocalStorage;\nexports.KeyValueStorage = KeyValueStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/storage.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nvar _ = require('lodash');\n\n\n/* Interface\n  type TransitionTable = {\n    [state: string]: ?{\n      [symbol: string]: Instruction\n    }\n  };\n  type Instruction = { state?: string, symbol?: string };\n\n  type DiagramGraph = {\n    [state: string]: {\n      label: string,\n      transitions: ?{\n        [symbol: string]: {\n          instruction: Instruction,\n          edge: LayoutEdge\n        }\n      }\n    }\n  };\n  type LayoutEdge = { source: Object, target: Object, labels: [string] }\n */\n\n/**\n * Use a transition table to derive the graph (vertices & edges) for a D3 diagram.\n * Edges with the same source and target are combined.\n * NB. In addition to single symbols, comma-separated symbols are supported.\n * e.g. symbol string '0,1,,,I' -> symbols [0,1,',','I'].\n */\n// TransitionTable -> DiagramGraph\nfunction deriveGraph(table) {\n  // We need two passes, since edges may point at vertices yet to be created.\n  // 1. Create all the vertices.\n  var graph = _.mapValues(table, function (transitions, state) {\n    return {\n      label: state,\n      transitions: transitions\n    };\n  });\n  // 2. Create the edges, which can now point at any vertex object.\n  var allEdges = [];\n  _.forEach(graph, function (vertex, state) {\n\n    vertex.transitions = vertex.transitions && (function () {\n      var stateTransitions = {};\n\n      // Combine edges with the same source and target\n      var cache = {};\n      function edgeTo(target, label, symbols) {\n        var edge = cache[target] ||\n          _.tap(cache[target] = {\n            source: vertex,\n            target: graph[target],\n            labels: [],\n            labelsForSymbol: {}\n          }, allEdges.push.bind(allEdges));\n        edge.labels.push(label);\n        for (var i = 0; i < symbols.length; i++)\n          edge.labelsForSymbol[symbols[i]] = label;\n        return edge;\n      }\n      // Create symbol -> instruction object map\n      _.forEach(vertex.transitions, function (instruct, symbolKey) {\n        // Handle comma-separated symbols.\n        // Recreate array by splitting on ','. Treat 2 consecutive ',' as , ','.\n        var symbols = symbolKey.split(',').reduce(function (acc, x) {\n          if (x === '' && acc[acc.length-1] === '') {\n            acc[acc.length-1] = ',';\n          } else {\n            acc.push(x);\n          }\n          return acc;\n        }, []);\n        var target = instruct.state != null ? instruct.state : state;\n        var edge = edgeTo(target, labelFor(symbols, instruct), symbols);\n\n        symbols.forEach(function (symbol) {\n          stateTransitions[symbol] = {\n            // Normalize for execution, but display the less-cluttered original.\n            instruction: normalize(state, symbol, instruct),\n            edge: edge\n          };\n        });\n      });\n\n      return stateTransitions;\n    }());\n\n  });\n\n  return {graph: graph, edges: allEdges};\n}\n\n// Normalize an instruction to include an explicit state and symbol.\n// e.g. {symbol: '1'} normalizes to {state: 'q0', symbol: '1'} when in state q0.\nfunction normalize(state, symbol, instruction) {\n  return _.defaults({}, instruction, {state: state, symbol: symbol});\n}\n\nfunction labelFor(symbols, action) {\n  var rightSide = ((action.symbol == null) ? '' : (visibleSpace(String(action.symbol)) + ','))\n    + String(action.move);\n  return symbols.map(visibleSpace).join(',') + '→' + rightSide;\n}\n\n// replace ' ' with '␣'.\nfunction visibleSpace(c) {\n  return (c === ' ') ? '␣' : c;\n}\n\n\n/**\n * Aids rendering and animating a transition table in D3.\n *\n * • Generates the vertices and edges (\"nodes\" and \"links\") for a D3 diagram.\n * • Provides mapping of each state to its vertex and each transition to its edge.\n * @param {TransitionTable} table\n */\nfunction StateGraph(table) {\n  var derived = deriveGraph(table);\n  Object.defineProperties(this, {\n    __graph: { value: derived.graph },\n    __edges: { value: derived.edges }\n  });\n}\n\n/**\n * D3 layout \"nodes\".\n */\n// StateGraph.prototype.getVertices = function () {\n//   return _.values(this.__graph);\n// };\n\n/**\n * Returns the mapping from states to vertices (D3 layout \"nodes\").\n * @return { {[state: string]: Object} }\n */\nStateGraph.prototype.getVertexMap = function () {\n  return this.__graph;\n};\n\n/**\n * D3 layout \"links\".\n */\nStateGraph.prototype.getEdges = function () {\n  return this.__edges;\n};\n\n/**\n * Look up a state's corresponding D3 \"node\".\n */\nStateGraph.prototype.getVertex = function (state) {\n  return this.__graph[state];\n};\n\nStateGraph.prototype.getInstructionAndEdge = function (state, symbol) {\n  var vertex = this.__graph[state];\n  if (vertex === undefined) {\n    throw new Error('not a valid state: ' + String(state));\n  }\n\n  return vertex.transitions && vertex.transitions[symbol];\n};\n\n\nmodule.exports = StateGraph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/state-diagram/StateGraph.js\n// module id = 12\n// module chunks = 0","module.exports = lodash;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 13\n// module chunks = 0","'use strict';\r\n\r\n//TODO (stretchiest goal) preserve the lower comments in code if possible (might be possible)\r\n\r\nvar isBrowserIEorEdge = require('../util').isBrowserIEorEdge;\r\nvar d3 = require('d3');\r\nvar jsyaml = require('js-yaml');\r\nvar ace = require('ace-builds/src-min-noconflict');\r\nvar _ = require('lodash/fp');\r\nvar assign = require('lodash').assign; // need mutable assign()\r\nvar KeyValueStorage = require('../storage').KeyValueStorage;\r\n\r\n//diagram direct edit form fields\r\nvar nodeEditControls = window.document.getElementById('node-edit-controls');\r\nvar transitionEditControls = window.document.getElementById('transition-edit-controls');\r\nvar nodeLabel = window.document.getElementById('nodeLabel');\r\nvar startState = window.document.getElementById('startState');\r\nvar read = window.document.getElementById('read');\r\nvar write = window.document.getElementById('write');\r\nvar moveL = window.document.getElementById('moveL');\r\nvar moveR = window.document.getElementById('moveR');\r\nvar deleteNode = window.document.getElementById('deleteNode');\r\nvar deleteLink = window.document.getElementById('deleteLink');\r\nvar source = ace.edit(document.getElementById('editor-container'));\r\n\r\n// *** Arrays as vectors ***\r\n\r\n// Add vectors.\r\n// Note: dimensions are not checked. Missing dimensions become NaN.\r\nfunction addV(array1, array2) {\r\n  return array1.map(function (x, i) { return x + array2[i]; });\r\n}\r\n\r\nfunction negateV(array) {\r\n  return array.map(function (x) { return -x; });\r\n}\r\n\r\nfunction subtractV(array1, array2) {\r\n  return addV(array1, negateV(array2));\r\n}\r\n\r\n// Scale the vector by a scalar.\r\nfunction multiplyV(array, scalar) {\r\n  return array.map(function (x) { return scalar*x; });\r\n}\r\n\r\n// Vector norm, squared\r\nfunction normSqV(array) {\r\n  function sq(x) { return x*x; }\r\n  function add(x, y) { return x + y; }\r\n  return array.map(sq).reduce(add, 0);\r\n}\r\n\r\n// Vector norm\r\nfunction normV(array) { return Math.sqrt(normSqV(array)); }\r\n\r\n// Return a copy of the vector rescaled as a unit vector (norm = 1).\r\nfunction unitV(array) {\r\n  var n = normV(array);\r\n  return array.map(function (x) { return x / n; });\r\n}\r\n\r\n// *** 2D Vectors ***\r\nfunction angleV(array) {\r\n  var x = array[0], y = array[1];\r\n  return Math.atan2(y, x);\r\n}\r\n\r\nfunction vectorFromLengthAngle(length, angle) {\r\n  return [Math.cos(angle) * length, Math.sin(angle) * length];\r\n}\r\n\r\n// *** Utilities ***\r\n\r\n//mouse event variables need to be global for the editing to work\r\nvar selectedNode = null;\r\nvar selectedLink = null;\r\n\r\nvar mousedownLink = null;\r\nvar mousedownNode = null;\r\nvar mouseupNode = null;\r\nvar mouseoverNode = false;\r\nvar mouseoverLink = false;\r\nvar mouseOverSameNode = false;\r\nvar mouseOver = 0;\r\nvar lastKeyDown = -1;\r\n\r\nvar queueReload = false;\r\n\r\nfunction resetMouseVars() {\r\n  mousedownNode = null;\r\n  mouseupNode = null;\r\n  mousedownLink = null;\r\n  mouseOverSameNode = false;\r\n}\r\n\r\n//Disable the edit controllers, reset EVERYTHING to foolproof this\r\n\r\nfunction disableNodeEditing() {\r\n  nodeLabel.disabled = true;\r\n  nodeLabel.value = '';\r\n  startState.disabled = true;\r\n  startState.checked = false;\r\n  deleteNode.disabled = true;\r\n  //remove the selected-node class from node\r\n  if(selectedNode) d3.select(selectedNode.domNode).classed('selected-node', false);\r\n  selectedNode = null;\r\n}\r\n\r\nfunction disableLinkEditing() {\r\n  read.disabled = true;\r\n  read.value = '';\r\n  write.disabled = true;\r\n  write.value = '';\r\n  moveL.disabled = true;\r\n  moveR.disabled = true;\r\n  deleteLink.disabled = true;\r\n  if(selectedLink) d3.select(selectedLink.domNode).classed('selected-edge', false);\r\n  selectedLink = null;\r\n}\r\nfunction disableEditing(){\r\n  disableNodeEditing();\r\n  disableLinkEditing();\r\n  transitionEditControls.setAttribute(\"style\", \"display: none\");\r\n  nodeEditControls.setAttribute(\"style\", \"display: flex\");\r\n}\r\n\r\nfunction selectionHasChanged() {\r\n  if (selectedLink) {\r\n    var transitionContents = selectedLink.labels[0].split(\"→\");\r\n    var splitTransition = transitionContents[1].split(\",\");\r\n  }\r\n  if (selectedNode && !(selectedNode['label'] === nodeLabel.value)) {\r\n    return true;\r\n  } else if (selectedLink && !(transitionContents[0] === read.value)) {\r\n    return true;\r\n  } else if (selectedLink && splitTransition.length > 1 && !(splitTransition[0] === write.value)){\r\n    return true;\r\n  } else return false;\r\n}\r\n\r\n//throw the error div on screen if the user does something that will invalidate the machine configuration\r\nfunction throwMachineError(errorInfo) {\r\n  var alerts = d3.select(window.document.getElementById(\"editor-alerts-container\"));\r\n\r\n  alerts.selectAll('.alert').remove();\r\n\r\n  alerts.append('div')\r\n    .attr('class', 'alert alert-danger')\r\n    .attr('role', 'alert')\r\n    .append('span').text(errorInfo);\r\n}\r\n\r\n// Count the directed edges that start at a given node and end at another.\r\n// Important: each node must have a unique .index property.\r\n// Example usage:\r\n// var counts = new EdgeCounter(edges);\r\n// var edgesFrom2To5 = counts.numEdgesFromTo(2,5);\r\n// var edgesFrom5to2 = counts.numEdgesFromTo(5,2);\r\nfunction EdgeCounter(edges) {\r\n  edges.forEach(function (e) {\r\n    var key = e.source.index +','+ e.target.index;\r\n    this[key] = (this[key] || 0) + 1;\r\n  }, this);\r\n}\r\n\r\nEdgeCounter.prototype.numEdgesFromTo = function (src, target) {\r\n  return this[String(src)+','+String(target)] || 0;\r\n};\r\n\r\nvar EdgeShape = Object.freeze({\r\n  loop: {},     // self-loop: a->a\r\n  arc: {},      // curved arc: a->b when b->a exists\r\n  straight: {}  // straight edge: a->b when b->a does not exist\r\n});\r\n\r\nEdgeCounter.prototype.shapeForEdge = function (e) {\r\n  if (e.target.index === e.source.index) {\r\n    return EdgeShape.loop;\r\n  } else if (this.numEdgesFromTo(e.target.index, e.source.index)) {\r\n    // has returning edge => arc\r\n    return EdgeShape.arc;\r\n  } else {\r\n    return EdgeShape.straight;\r\n  }\r\n};\r\n\r\n// create a function that will compute an edge's SVG 'd' attribute.\r\nfunction edgePathFor(nodeRadius, shape, d) {\r\n  // case: self-loop\r\n  var loopEndOffset, loopArc;\r\n  if (shape === EdgeShape.loop) {\r\n    // start at the top (90°), end slightly above the right (15°)\r\n    loopEndOffset = vectorFromLengthAngle(nodeRadius, -15 * Math.PI/180);\r\n    loopArc = ' a 19,27 45 1,1 ' + loopEndOffset[0] + ',' + (loopEndOffset[1]+nodeRadius);\r\n    return function () {\r\n      var x1 = d.source.x,\r\n          y1 = d.source.y;\r\n      return 'M ' + x1 + ',' + (y1-nodeRadius) + loopArc;\r\n    };\r\n  }\r\n  // case: between nodes\r\n  if (shape === EdgeShape.arc) {\r\n    // sub-case: arc\r\n    return function () {\r\n      // note: p1 & p2 have to be delayed, to access x/y at the time of the call\r\n      var p1 = [d.source.x, d.source.y];\r\n      var p2 = [d.target.x, d.target.y];\r\n      var offset = subtractV(p2, p1);\r\n      var radius = 6/5*normV(offset);\r\n      // Note: SVG's y-axis is flipped, so vector angles are negative\r\n      // relative to standard coordinates (as used in Math.atan2).\r\n      // Proof: angle(r <cos ϴ, -sin ϴ>) = angle(r <cos -ϴ, sin -ϴ>) = -ϴ.\r\n      var angle = angleV(offset);\r\n      var sep = -Math.PI/2/2; // 90° separation, half on each side\r\n      var source = addV(p1, vectorFromLengthAngle(nodeRadius, angle+sep));\r\n      var target = addV(p2, vectorFromLengthAngle(nodeRadius, angle+Math.PI-sep));\r\n      // IDEA: consider http://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands\r\n      return (p1[0] <= p2[0])\r\n        ? 'M '+source[0]+' '+source[1]+' A '+radius+' '+radius+' 0 0,1 '+target[0]+' '+target[1]\r\n        : 'M '+target[0]+' '+target[1]+' A '+radius+' '+radius+' 0 0,0 '+source[0]+' '+source[1];\r\n    };\r\n  } else if (shape === EdgeShape.straight) {\r\n    return function () {\r\n      // sub-case: straight line\r\n      var p1 = [d.source.x, d.source.y];\r\n      var p2 = [d.target.x, d.target.y];\r\n      var offset = subtractV(p2, p1);\r\n      // avoid spurious errors when bounding causes node centers to coincide\r\n      if (offset[0] === 0 && offset[1] === 0) { return null; }\r\n\r\n      var target = subtractV(p2, multiplyV(unitV(offset), nodeRadius));\r\n      return 'M '+p1[0]+' '+p1[1]+' L '+ target[0] +' '+ target[1];\r\n    };\r\n  }\r\n}\r\n\r\nfunction rectCenter(svgrect) {\r\n  return {x: svgrect.x + svgrect.width/2,\r\n    y: svgrect.y + svgrect.height/2};\r\n}\r\n\r\nfunction identity(x) { return x; }\r\nfunction noop() {}\r\n\r\nfunction limitRange(min, max, value) {\r\n  return Math.max(min, Math.min(value, max));\r\n}\r\n\r\n// IE padding hack so that SVG resizes properly.\r\n// This works across browsers but we only need it for IE.\r\nvar appendSVGTo = !isBrowserIEorEdge\r\n  ? function (div) { return div.append('svg'); }\r\n  : function (div, hwRatio) {\r\n    return div\r\n      .append('div')\r\n        .style({\r\n          width: '100%',\r\n          height: '0',\r\n          'padding-bottom': (100 * hwRatio) + '%',\r\n          position: 'relative'\r\n        })\r\n      .append('svg')\r\n        .style({\r\n          position: 'absolute',\r\n          top: '0',\r\n          left: '0'\r\n        });\r\n  };\r\n\r\n// *** D3 diagram ***\r\nrequire('./StateViz.css');\r\nconst util = require('../util');\r\nconst parser = require('../parser');\r\n\r\n// type LayoutNode = {label: string};\r\n// type StateMap = {[state: string]: LayoutNode};\r\n\r\n/**\r\n * Create a state diagram inside an SVG.\r\n * Each vertex/edge (node/link) object is also annotated with @.domNode@\r\n * corresponding to its SVG element.\r\n *\r\n * Note: currently, element IDs (e.g. for textPath) will collide if multiple\r\n * diagrams are on the same document (HTML page).\r\n * @param  {D3Selection}      container     Container to add the SVG to.\r\n * @param  {[LayoutNode] | StateMap} nodes  Parameter to D3's force.nodes.\r\n *   Important: passing a StateMap is recommended when using setPositionTable.\r\n *   Passing an array will key the state nodes by array index.\r\n * @param  {[LayoutEdge]}     linkArray     Parameter to D3's force.links.\r\n */\r\nfunction StateViz(container, nodes, linkArray) {\r\n  /* References:\r\n    [Sticky Force Layout](http://bl.ocks.org/mbostock/3750558) demonstrates\r\n    drag to position and double-click to release.\r\n\r\n    [Graph with labeled edges](http://bl.ocks.org/jhb/5955887) demonstrates\r\n    arrow edges with auto-rotated labels.\r\n\r\n    [Directed Graph Editor](https://gist.github.com/rkirsling/5001347) demonstrates\r\n    a node graph sandbox with dragging for both moving nodes and adding edges.\r\n  */\r\n\r\n  /* eslint-disable no-invalid-this */ // eslint is not familiar with D3\r\n  var w = 800;\r\n  var h = 500;\r\n  var linkDistance = 140;\r\n  var nodeRadius = 20;\r\n\r\n  var colors = d3.scale.category10();\r\n\r\n  var svg = appendSVGTo(container, h / w);\r\n\r\n  svg.attr({\r\n    'viewBox': [0, 0, w, h].join(' '),\r\n    'version': '1.1',\r\n    ':xmlns': 'http://www.w3.org/2000/svg',\r\n    ':xmlns:xlink': 'http://www.w3.org/1999/xlink'\r\n  });\r\n\r\n  svg.on('contextmenu', function () {\r\n    d3.event.preventDefault();\r\n  });\r\n\r\n  // Force Layout\r\n\r\n  // drag event handlers\r\n  function dragstart(d) {\r\n    d.fixed = true; //stays where you put it\r\n    svg.transition()\r\n      .style('box-shadow', 'inset 0 0 2px gold'); //yellow around canvas\r\n  }\r\n\r\n  function dragend() {\r\n    svg.transition()\r\n      .style('box-shadow', null); //yellow around canvas\r\n  }\r\n\r\n  var dragLine = svg.append('path')\r\n    .attr('class', 'link dragline hidden')\r\n    .attr('d', 'M0,0L0,0');\r\n\r\n  //this function used to release the node if it was double-clicked on\r\n  /*function releasenode(d) {\r\n    d.fixed = false;\r\n    force.resume(); //happens on double click rn\r\n  }*/\r\n\r\n  // set up force layout\r\n  var nodeArray = nodes instanceof Array ? nodes : _.values(nodes);\r\n  this.__stateMap = nodes;\r\n\r\n  var force = d3.layout.force()\r\n    .nodes(nodeArray)\r\n    .links(linkArray)\r\n    .size([w, h])\r\n    .linkDistance([linkDistance])\r\n    .charge([-500])\r\n    .theta(0.1)\r\n    .gravity(0.05)\r\n    .start();\r\n\r\n  var drag = force.drag()\r\n    .on('dragstart', dragstart)\r\n    .on('dragend', dragend);\r\n\r\n  // Edges\r\n  var edgeCounter = new EdgeCounter(linkArray);\r\n\r\n  var edgeselection = svg.selectAll('.edgepath')\r\n    .data(linkArray)\r\n    .enter();\r\n\r\n  var edgegroups = edgeselection.append('g');\r\n\r\n  var labelAbove = function (d, i) {\r\n    return String(-1.1 * (i + 1)) + 'em';\r\n  };\r\n  var labelBelow = function (d, i) {\r\n    return String(0.6 + 1.1 * (i + 1)) + 'em';\r\n  };\r\n\r\n  edgegroups.each(function (edgeD, edgeIndex) {\r\n    var group = d3.select(this);\r\n    var edgepath = group\r\n      .append('path')\r\n      .attr({\r\n        'class': 'edgepath transition',\r\n        'id': 'edgepath' + edgeIndex\r\n      })\r\n      .each(function (d) {\r\n        d.domNode = this;\r\n      })\r\n      .on('mousedown', (d) => {\r\n        if (d3.event.ctrlKey) return;\r\n\r\n        // select link\r\n        mousedownLink = d;\r\n        //remove the edgepath.selected-edge class to the node if one already selected\r\n        if (selectedLink) d3.select(selectedLink.domNode).classed('selected-edge', false);\r\n        selectedLink = mousedownLink;\r\n        //remove the selected-node class from node\r\n        if (selectedNode) d3.select(selectedNode.domNode).classed('selected-node', false);\r\n        selectedNode = null;\r\n\r\n        //add the edgepath.selected-edge class to the node\r\n        d3.select(selectedLink.domNode).classed('selected-edge', true);\r\n\r\n        //re-enable the editing\r\n        read.disabled = false;\r\n        write.disabled = false;\r\n        moveL.disabled = false;\r\n        moveR.disabled = false;\r\n        deleteLink.disabled = false;\r\n\r\n        var boxContents = selectedLink.labels[0].split(\"→\");\r\n        read.value = boxContents[0];\r\n        if (boxContents[1].includes(\",\")) {\r\n          var splitTransition = boxContents[1].split(\",\");\r\n          write.value = splitTransition[0];\r\n          moveL.disabled = (splitTransition[1] === \"L\");\r\n          moveL.classList.toggle('btn-secondary', !(splitTransition[1] === \"L\"));\r\n          moveL.classList.toggle('btn-success', (splitTransition[1] === \"L\"));\r\n          moveR.disabled = !(splitTransition[1] === \"L\");\r\n          moveR.classList.toggle('btn-success', !(splitTransition[1] === \"L\"));\r\n          moveR.classList.toggle('btn-secondary', (splitTransition[1] === \"L\"));\r\n        } else {\r\n          write.value = \"\";\r\n          moveL.disabled = (boxContents[1] === \"L\");\r\n          moveL.classList.toggle('btn-secondary', !(boxContents[1] === \"L\"))\r\n          moveL.classList.toggle('btn-success', (boxContents[1] === \"L\"))\r\n          moveR.disabled = !(boxContents[1] === \"L\");\r\n          moveR.classList.toggle('btn-success', !(boxContents[1] === \"L\"))\r\n          moveR.classList.toggle('btn-secondary', (boxContents[1] === \"L\"))\r\n        }\r\n\r\n        disableNodeEditing();\r\n        nodeEditControls.setAttribute(\"style\", \"display: none\");\r\n        transitionEditControls.setAttribute(\"style\", \"display: flex\");\r\n\r\n        force.resume();\r\n      })\r\n      .on('mouseover', function () {\r\n        mouseoverLink = true;\r\n      })\r\n      .on('mouseout', function () {\r\n        mouseoverLink = false;\r\n      })\r\n\r\n    var labels = group.selectAll('.edgelabel')\r\n      .data(edgeD.labels).enter()\r\n      .append('text')\r\n      .attr('class', 'edgelabel');\r\n    labels.append('textPath')\r\n      .attr('xlink:href', function () {\r\n        return '#edgepath' + edgeIndex;\r\n      })\r\n      .attr('startOffset', '50%')\r\n      .text(identity);\r\n    /* To reduce JS computation, label positioning varies by edge shape:\r\n        * Straight edges can use a fixed 'dy' value.\r\n        * Loops cannot use 'dy' since it increases letter spacing\r\n          as labels get farther from the path. Instead, since a loop's shape\r\n          is fixed, it allows a fixed translate 'transform'.\r\n        * Arcs are bent and their shape is not fixed, so neither 'dy'\r\n          nor 'transform' can be constant.\r\n          Fortunately the curvature is slight enough that a fixed 'dy'\r\n          looks good enough without resorting to dynamic translations.\r\n    */\r\n    var shape = edgeCounter.shapeForEdge(edgeD);\r\n    edgeD.getPath = edgePathFor(nodeRadius, shape, edgeD);\r\n    switch (shape) {\r\n      case EdgeShape.straight:\r\n        labels.attr('dy', labelAbove);\r\n        edgeD.refreshLabels = function () {\r\n          // flip edge labels that are upside-down\r\n          labels.attr('transform', function () {\r\n            if (edgeD.target.x < edgeD.source.x) {\r\n              var c = rectCenter(this.getBBox());\r\n              return 'rotate(180 ' + c.x + ' ' + c.y + ')';\r\n            } else {\r\n              return null;\r\n            }\r\n          });\r\n        };\r\n        break;\r\n      case EdgeShape.arc:\r\n        var isFlipped;\r\n        edgeD.refreshLabels = function () {\r\n          var shouldFlip = edgeD.target.x < edgeD.source.x;\r\n          if (shouldFlip !== isFlipped) {\r\n            edgepath.classed('reversed-arc', shouldFlip);\r\n            labels.attr('dy', shouldFlip ? labelBelow : labelAbove);\r\n            isFlipped = shouldFlip;\r\n          }\r\n        };\r\n        break;\r\n      case EdgeShape.loop:\r\n        labels.attr('transform', function (d, i) {\r\n          return 'translate(' + String(8 * (i + 1)) + ' ' + String(-8 * (i + 1)) + ')';\r\n        });\r\n        edgeD.refreshLabels = noop;\r\n        break;\r\n    }\r\n    //whole section above is just about the shape of the node arrows, probably don't touch\r\n  });\r\n  var edgepaths = edgegroups.selectAll('.edgepath');\r\n\r\n  // Nodes\r\n  // note: nodes are added after edges so as to paint over excess edge lines\r\n  var nodeSelection = svg.selectAll('.node')\r\n    .data(nodeArray)\r\n    .enter();\r\n\r\n  var nodecircles = nodeSelection\r\n    .append('circle')\r\n    .attr('class', 'node')\r\n    .attr('r', nodeRadius)\r\n    .style('fill', function (d, i) {\r\n      return colors(i);\r\n    })\r\n    // .style('fill', function (d,i) {\r\n    //   if (d === selectedNode) {\r\n    //     return d3.rgb(colors(i).brighter().toString());\r\n    //   } else return colors(i);\r\n    //  })\r\n    .each(function (d) {\r\n      d.domNode = this;\r\n    })\r\n    .call(drag)\r\n    .on('mousedown', function (d) {\r\n      mousedownNode = d;\r\n      if (!d3.event.ctrlKey) {\r\n\r\n        // select node\r\n        if (mousedownNode === selectedNode) {\r\n          return;\r\n        } else {\r\n          //remove the selected-node class from node if one already selected\r\n          if (selectedNode) d3.select(selectedNode.domNode).classed('selected-node', false);\r\n          selectedNode = mousedownNode;\r\n\r\n          // add selected-node class to the node\r\n          d3.select(selectedNode.domNode).classed('selected-node', true);\r\n          //re-enable the editing\r\n          nodeLabel.disabled = false;\r\n          deleteNode.disabled = false;\r\n\r\n          var checkStartState = function () {\r\n            var machine = jsyaml.safeLoad(source.getValue());\r\n            if (machine['start state'] === selectedNode.label) {\r\n              startState.disabled = true;\r\n              return true;\r\n            } else {\r\n              startState.disabled = false;\r\n              return false;\r\n            }\r\n          }\r\n\r\n          var isStartState = checkStartState();\r\n\r\n          nodeLabel.value = selectedNode.label;\r\n          startState.checked = isStartState;\r\n        }\r\n        //remove the edgepath.selected-edge class from the node\r\n        if (selectedLink) d3.select(selectedLink.domNode).classed('selected-edge', false);\r\n        selectedLink = null;\r\n        disableLinkEditing();\r\n        transitionEditControls.setAttribute(\"style\", \"display: none\");\r\n        nodeEditControls.setAttribute(\"style\", \"display: flex\");\r\n\r\n      } else {\r\n        //start dragline\r\n        dragLine\r\n          .classed('hidden', false)\r\n          .attr('d', 'M' + mousedownNode.x + ',' + mousedownNode.y + 'L' + mousedownNode.x + ',' + mousedownNode.y);\r\n      }\r\n      force.resume();\r\n    })\r\n    .on('mouseover', function (d) {\r\n      mouseoverNode = true;\r\n\r\n      if (!mousedownNode) return;\r\n\r\n      if (d === mousedownNode) {\r\n        mouseOverSameNode = true;\r\n      }\r\n    })\r\n    .on('mouseout', function () {\r\n      mouseoverNode = false;\r\n\r\n      if (!mousedownNode) return;\r\n\r\n      if (mouseOverSameNode) mouseOverSameNode = false;\r\n    })\r\n    .on('mouseup', function (d) {\r\n      if (!mousedownNode) return;\r\n\r\n      // needed by FF\r\n      dragLine\r\n        .classed('hidden', true)\r\n        .style('marker-end', '');\r\n\r\n      mouseupNode = d;\r\n\r\n      if (lastKeyDown === 17) {\r\n        // add link to graph (update if exists)\r\n        var machine = jsyaml.safeLoad(source.getValue());\r\n        // throw error if default transition already exists\r\n        if (machine.table[mousedownNode.label].hasOwnProperty('?')) {\r\n          throwMachineError(\"Edit the last transition before adding a new one (each symbol can only appear on one transition at a time)\");\r\n        } else {\r\n          machine.table[mousedownNode.label]['?'] = {R: mouseupNode.label};\r\n          source.setValue(jsyaml.safeDump(machine));\r\n          KeyValueStorage.write('TMReload', 'new link');\r\n          disableEditing();\r\n        }\r\n      }\r\n\r\n      force.resume();\r\n    });\r\n\r\n  var nodelabels = nodeSelection\r\n    .append('text')\r\n    .attr('class', 'nodelabel')\r\n    .attr('dy', '0.25em') /* dy doesn't work in CSS */\r\n    .text(function (d) {\r\n      return d.label;\r\n    });\r\n\r\n  // Arrowheads\r\n  var svgdefs = svg.append('defs');\r\n  svgdefs.selectAll('marker')\r\n    .data(['arrowhead', 'active-arrowhead', 'reversed-arrowhead', 'reversed-active-arrowhead'])\r\n    .enter().append('marker')\r\n    .attr({\r\n      'id': function (d) {\r\n        return d;\r\n      },\r\n      'viewBox': '0 -5 10 10',\r\n      'refX': function (d) {\r\n        return (d.lastIndexOf('reversed-', 0) === 0) ? 0 : 10;\r\n      },\r\n      'orient': 'auto',\r\n      'markerWidth': 3,\r\n      'markerHeight': 3\r\n    })\r\n    .append('path')\r\n    .attr('d', 'M 0 -5 L 10 0 L 0 5 Z')\r\n    .attr('transform', function (d) {\r\n      return (d.lastIndexOf('reversed-', 0) === 0) ? 'rotate(180 5 0)' : null;\r\n    });\r\n\r\n  //not sure why i cant move this into the css but we ball\r\n  var svgCSS =\r\n    '.edgepath {' +\r\n    '  marker-end: url(#arrowhead);' +\r\n    '}' +\r\n    '.edgepath.active-edge {' +\r\n    '  marker-end: url(#active-arrowhead);' +\r\n    '}' +\r\n    '.edgepath.reversed-arc {' +\r\n    '  marker-start: url(#reversed-arrowhead);' +\r\n    '  marker-end: none;' +\r\n    '}' +\r\n    '.edgepath.active-edge.reversed-arc {' +\r\n    '  marker-start: url(#reversed-active-arrowhead);' +\r\n    '  marker-end: none;' +\r\n    '}';\r\n  svg.append('style').each(function () {\r\n    if (this.styleSheet) {\r\n      this.styleSheet.cssText = svgCSS;\r\n    } else {\r\n      this.textContent = svgCSS;\r\n    }\r\n  })\r\n\r\n  // Force Layout Update\r\n  force.on('tick', function () {\r\n    // Keep coordinates in bounds. http://bl.ocks.org/mbostock/1129492\r\n    // NB. Bounding can cause node centers to coincide, especially at corners.\r\n    nodecircles.attr({\r\n      cx: function (d) {\r\n        return d.x = limitRange(nodeRadius, w - nodeRadius, d.x);\r\n      },\r\n      cy: function (d) {\r\n        return d.y = limitRange(nodeRadius, h - nodeRadius, d.y);\r\n      }\r\n    });\r\n\r\n    nodelabels.attr('x', function (d) {\r\n      return d.x;\r\n    })\r\n      .attr('y', function (d) {\r\n        return d.y;\r\n      });\r\n\r\n    edgepaths.attr('d', function (d) {\r\n      return d.getPath();\r\n    });\r\n\r\n    edgegroups.each(function (d) {\r\n      d.refreshLabels();\r\n    });\r\n\r\n    // Conserve CPU when layout is fully fixed\r\n    if (nodeArray.every(function (d) {\r\n      return d.fixed;\r\n    })) {\r\n      force.stop();\r\n    }\r\n  });\r\n  this.force = force;\r\n\r\n  //in this section begin the functions that enable the visual editing functionality\r\n  //these are going to be pretty hacky so that they work, both because this is written in quite an\r\n  //old version of javascript without classes and that I have very little experience working in this language\r\n  //This entire codebase probably needs a rewrite, but I don't have the time, energy or motivation to do this\r\n\r\n  if (lastKeyDown === 17) {\r\n    nodecircles.on('.drag', null)\r\n      .classed('node', false);\r\n  }\r\n\r\n  //add a node\r\n  svg.on('dblclick', function () {\r\n\r\n    if (d3.event.ctrlKey || mouseoverNode || mouseoverLink) return;\r\n    //var source = controller.editor;\r\n    var machine = jsyaml.safeLoad(source.getValue());\r\n    //node name increments\r\n    var newNodeIndex = (_.keys(machine.table).length + 1);\r\n    var newNodeName;\r\n    //check if counted node already exists and then add 1 (for all possible nodes)\r\n    //yes this doesnt fill holes but its the simplest way to deal with this that I can think of\r\n    for (var node in machine.table) {\r\n      newNodeName = \"State\" + newNodeIndex.toString();\r\n      if (machine.table.hasOwnProperty(newNodeName))\r\n        newNodeIndex++;\r\n    }\r\n    machine.table[newNodeName] = {};\r\n    source.setValue(jsyaml.safeDump(machine));\r\n    disableEditing();\r\n    nodeLabel.value = '';\r\n    KeyValueStorage.write('TMReload', 'node');\r\n  });\r\n\r\n  //deselect node\r\n  svg.on('mousedown', function () {\r\n    if (mousedownNode || mousedownLink) return;\r\n\r\n    //reset the containers and disable them?\r\n    if (selectedNode || selectedLink) {\r\n      //has anything changed?\r\n      if (selectionHasChanged()) {\r\n        queueReload = true;\r\n        KeyValueStorage.write('TMReload', 'reload');\r\n      } else {\r\n        disableEditing();\r\n        resetMouseVars();\r\n      }\r\n    }\r\n  });\r\n\r\n  //drag a node or link a transition\r\n  svg.on('mousemove', function () {\r\n    if (!mousedownNode) return;\r\n\r\n    // update drag line\r\n    if (mouseOverSameNode) {\r\n      dragLine.attr('d', function () {\r\n        var loopEndOffset, loopArc;\r\n        // start at the top (90°), end slightly above the right (15°)\r\n        loopEndOffset = vectorFromLengthAngle(nodeRadius, -15 * Math.PI / 180);\r\n        loopArc = ' a 19,27 45 1,1 ' + loopEndOffset[0] + ',' + (loopEndOffset[1] + nodeRadius);\r\n        var x1 = mousedownNode.x,\r\n          y1 = mousedownNode.y;\r\n        return 'M ' + x1 + ',' + (y1 - nodeRadius) + loopArc;\r\n      })\r\n    } else dragLine.attr('d', 'M' + mousedownNode.x + ',' + mousedownNode.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\r\n  });\r\n\r\n  //finish a drag/transition\r\n  svg.on('mouseup', function () {\r\n    if (mousedownNode) {\r\n      // hide drag line\r\n      dragLine\r\n        .classed('hidden', true)\r\n        .style('marker-end', '');\r\n    }\r\n\r\n    // clear mouse event vars\r\n    resetMouseVars();\r\n  });\r\n\r\n  svg.on('mouseenter', function () {\r\n    mouseOver = 1;\r\n  })\r\n    .on('mouseleave', function () {\r\n      mouseOver = 0;\r\n    });\r\n\r\n  d3.select(window)\r\n    .on('keydown', function () {\r\n\r\n      if (lastKeyDown !== -1) return;\r\n      lastKeyDown = d3.event.keyCode;\r\n\r\n      // ctrl\r\n      if (d3.event.keyCode === 17) {\r\n        nodecircles.on('.drag', null)\r\n          .classed('node', false);\r\n        return;\r\n      }\r\n\r\n      if (!selectedNode && !selectedLink) return;\r\n      if (!mouseOver) return;\r\n      switch (d3.event.keyCode) {\r\n        //delete\r\n        case 46: // delete\r\n          if (selectedNode) {\r\n            //delete the selected node\r\n            //get machine code\r\n            if (!startState.checked) {\r\n              var machine = jsyaml.safeLoad(source.getValue());\r\n              //delete every transition with the same name as the node being deleted\r\n              delete machine.table[selectedNode['label']];\r\n              for (var node in machine.table) {\r\n                for (var r in machine.table[node]) {\r\n                  for (var i in machine.table[node][r]) {\r\n                    if (i === \"L\" | i === \"R\") {\r\n                      if (machine.table[node][r][i] === selectedNode['label'])\r\n                        delete machine.table[node][r];\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              source.setValue(jsyaml.safeDump(machine));\r\n              disableEditing();\r\n              KeyValueStorage.write('TMReload', 'deleted a node');\r\n            } else {\r\n              //don't let the user delete the start state\r\n              throwMachineError(\"Change the start state before trying to delete this node\");\r\n            }\r\n          } else if (selectedLink) {\r\n            //delete the selected transition\r\n            //grab the machine\r\n            var machine = jsyaml.safeLoad(source.getValue());\r\n            delete machine['table'][selectedLink.source['label']][read.value];\r\n            //we're finished here\r\n            source.setValue(jsyaml.safeDump(machine));\r\n            disableEditing();\r\n            KeyValueStorage.write('TMReload', 'delete link');\r\n          }\r\n          //reload the simulation\r\n          break;\r\n\r\n        //TODO (stretch goal) add undo and redo functions - an array in util.js\r\n      }\r\n    })\r\n    .on('keyup', function () {\r\n      lastKeyDown = -1;\r\n\r\n      if (d3.event.keyCode === 17) {\r\n        nodecircles.call(drag)\r\n          .classed('node', true);\r\n      }\r\n    })\r\n\r\n  //preserve selected node if necessary\r\n  if (queueReload) {\r\n    disableEditing();\r\n    resetMouseVars();\r\n    queueReload = false;\r\n  } else if (nodeLabel.value){\r\n    //LORD KNOWS HOW THIS WORKS\r\n    var preservedNode = nodecircles.filter(function(d) { return d.label === nodeLabel.value })[0];\r\n    selectedNode = preservedNode[0].__data__;\r\n    d3.select(selectedNode.domNode).classed('selected-node', true);\r\n  } else if (read.value) {\r\n    //I STILL do not know how to traverse d3 objects using efficient code so this will fucking do\r\n    var preservedLabel = read.value + \"→\" + (write.value ? write.value + \",\" : \"\") + (moveL.disabled ? \"L\" : \"R\");\r\n    var preservedTransition = edgeselection[0].filter(function(d) {\r\n      return d.__data__['labels'][0] === preservedLabel;\r\n    });\r\n    var tempTransition = preservedTransition.filter(function (d) {\r\n      var tempObj = d.__data__;\r\n      return (tempObj.source['label'] === selectedLink.source.label && tempObj.target['label'] === selectedLink.target.label);\r\n    })[0];\r\n    selectedLink = tempTransition.__data__;\r\n    d3.select(selectedLink.domNode).classed('selected-edge', true);\r\n  }\r\n  /* eslint-enable no-invalid-this */\r\n}\r\n\r\n//edit controls for good enjoyable editing\r\nnodeLabel.addEventListener('focusout', function() {\r\n  // first make sure the node name actually changed\r\n  if (!(selectedNode['label'] === nodeLabel.value)) {\r\n    // get machine code\r\n    var machine = jsyaml.safeLoad(source.getValue());\r\n    // does a node with this new name exist already?\r\n    if (!(machine.table[nodeLabel.value] === undefined)) {\r\n      // a node exists already\r\n      throwMachineError(\"A node with that name exists already.\");\r\n    } else {\r\n      // we're changing the name of the node\r\n      machine.table[nodeLabel.value] = machine.table[selectedNode['label']];\r\n      delete machine.table[selectedNode['label']];\r\n      //make sure the start state changes if necessary\r\n      if (machine['start state'] === selectedNode['label']) {\r\n        machine['start state'] = nodeLabel.value;\r\n      }\r\n      // change every transition destination node that has the old node's name\r\n      for(var node in machine.table) {\r\n        for (var read in machine.table[node]) {\r\n          for (var i in machine.table[node][read]) {\r\n            if(i === \"L\" | i === \"R\") {\r\n              if (machine.table[node][read][i] === selectedNode['label'])\r\n                machine.table[node][read][i] = nodeLabel.value;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      //we're finished here\r\n      source.setValue(jsyaml.safeDump(machine));\r\n      KeyValueStorage.write('TMReload', 'node name change');\r\n    }\r\n  }\r\n});\r\n\r\nstartState.addEventListener('change', function(){\r\n  //this one is pretty foolproof\r\n  var machine = jsyaml.safeLoad(source.getValue());\r\n  machine['start state'] = nodeLabel.value;\r\n  startState.disabled = true;\r\n  source.setValue(jsyaml.safeDump(machine));\r\n  KeyValueStorage.write('TMReload', 'start state');\r\n})\r\n\r\ndeleteNode.addEventListener('click', function (){\r\n  //this one needs the full transition loop sorting before it works fully but basic node deletion is pretty easy\r\n  //get machine code\r\n  if(!startState.checked) {\r\n    var machine = jsyaml.safeLoad(source.getValue());\r\n    //delete every transition with the same name as the node being deleted\r\n    delete machine.table[nodeLabel.value];\r\n    for (var node in machine.table) {\r\n      for (var read in machine.table[node]) {\r\n        for (var i in machine.table[node][read]) {\r\n          if(i === \"L\" | i === \"R\") {\r\n            if (machine.table[node][read][i] === nodeLabel.value)\r\n              delete machine.table[node][read];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    source.setValue(jsyaml.safeDump(machine));\r\n    disableEditing();\r\n    KeyValueStorage.write('TMReload', 'deleted a node');\r\n  } else {\r\n    //don't let the user delete the start state\r\n    throwMachineError(\"Change the start state before trying to delete this node\");\r\n  }\r\n})\r\n\r\nread.addEventListener('focusout', function () {\r\n  //has the contents of the box changed?\r\n  var transitionContents = selectedLink.labels[0].split(\"→\");\r\n  if(!(transitionContents[0] === read.value)) {\r\n    //get machine\r\n    var machine = jsyaml.safeLoad(source.getValue());\r\n    //check if any read symbol duplicated (the guy didnt implement this to begin with)\r\n    var readSymbolExists = 0;\r\n    for (var readSymbol in machine.table[selectedLink.source['label']]) {\r\n      for (var symbol of read.value.split(\",\")){\r\n        if (readSymbol.includes(symbol) && !(transitionContents[0].includes(symbol))) {\r\n          readSymbolExists = 1;\r\n          break;\r\n        }\r\n      }\r\n      if (readSymbolExists) break;\r\n    }\r\n    if(!readSymbolExists) {\r\n      //delete entry corresponding to old read symbol(s), re-add entry with new read symbols\r\n      machine['table'][selectedLink.source['label']][read.value] = machine['table'][selectedLink.source['label']][transitionContents[0]];\r\n      delete machine['table'][selectedLink.source['label']][transitionContents[0]];\r\n      //we're finished here\r\n      source.setValue(jsyaml.safeDump(machine));\r\n      KeyValueStorage.write('TMReload', 'transition changed');\r\n    } else {\r\n      //throw error if any read symbol appears elsewhere in the source node's table\r\n      throwMachineError(\"One or more entered read symbol(s) appear(s) in another transition\");\r\n    }\r\n  }\r\n})\r\n\r\nwrite.addEventListener('focusout', function () {\r\n  var boxContents = selectedLink.labels[0].split(\"→\");\r\n  if(boxContents[1].includes(\",\")) {\r\n    var splitTransition = boxContents[1].split(\",\");\r\n    if(!(splitTransition[0] === write.value)){\r\n      //get machine\r\n      var machine = jsyaml.safeLoad(source.getValue());\r\n      //replace the written symbol or delete it if write left empty\r\n      if(write.value) {\r\n        machine['table'][selectedLink.source['label']][boxContents[0]]['write'] = write.value;\r\n      } else {\r\n        delete machine['table'][selectedLink.source['label']][boxContents[0]]['write'];\r\n      }\r\n      //we're finished here\r\n      source.setValue(jsyaml.safeDump(machine));\r\n      KeyValueStorage.write('TMReload', 'transition write changed');\r\n    }\r\n  } else {\r\n    if(write.value) {\r\n      //there is now a value for write\r\n      //grab the machine\r\n      var machine = jsyaml.safeLoad(source.getValue());\r\n      //add a write parameter to the object\r\n      machine['table'][selectedLink.source['label']][boxContents[0]]['write'] = write.value;\r\n      //we're finished here\r\n      source.setValue(jsyaml.safeDump(machine));\r\n      KeyValueStorage.write('TMReload', 'transition write changed');\r\n    }\r\n  }\r\n})\r\n\r\nmoveL.addEventListener('click', function () {\r\n  //probably pretty simple\r\n  //disable L, enable R, push L transition, delete R transition\r\n  moveL.disabled = true;\r\n  moveR.disabled = false;\r\n  moveL.classList.toggle('btn-secondary');\r\n  moveL.classList.toggle('btn-success');\r\n  moveR.classList.toggle('btn-success');\r\n  moveR.classList.toggle('btn-secondary');\r\n\r\n  //grab the machine\r\n  var machine = jsyaml.safeLoad(source.getValue());\r\n  //find the transition based on source node and read box\r\n  machine['table'][selectedLink.source['label']][read.value]['L'] = machine['table'][selectedLink.source['label']][read.value]['R'];\r\n  delete machine['table'][selectedLink.source['label']][read.value]['R'];\r\n  //we're finished here\r\n  source.setValue(jsyaml.safeDump(machine));\r\n  KeyValueStorage.write('TMReload', 'head movement changed');\r\n})\r\n\r\nmoveR.addEventListener('click', function () {\r\n  //probably pretty simple\r\n  //disable R, enable L, push R transition, delete L transition\r\n  moveR.disabled = true;\r\n  moveL.disabled = false;\r\n  moveR.classList.toggle('btn-secondary');\r\n  moveR.classList.toggle('btn-success');\r\n  moveL.classList.toggle('btn-success');\r\n  moveL.classList.toggle('btn-secondary');\r\n\r\n  //grab the machine\r\n  var machine = jsyaml.safeLoad(source.getValue());\r\n  //find the transition based on source node and read box\r\n  machine['table'][selectedLink.source['label']][read.value]['R'] = machine['table'][selectedLink.source['label']][read.value]['L'];\r\n  delete machine['table'][selectedLink.source['label']][read.value]['L'];\r\n  //we're finished here\r\n  source.setValue(jsyaml.safeDump(machine));\r\n  KeyValueStorage.write('TMReload', 'head movement changed');\r\n})\r\n\r\ndeleteLink.addEventListener('click', function (){\r\n  //this should be easier than deleting a node\r\n  //find read symbols inside source node object, delete read symbols (without replacing)\r\n  //grab the machine\r\n  var machine = jsyaml.safeLoad(source.getValue());\r\n  delete machine['table'][selectedLink.source['label']][read.value];\r\n  //we're finished here\r\n  source.setValue(jsyaml.safeDump(machine));\r\n  disableEditing();\r\n  KeyValueStorage.write('TMReload', 'delete link');\r\n})\r\n\r\n// Positioning\r\n\r\n// {[key: State]: Node} -> PositionTable\r\nvar getPositionTable = _.mapValues(_.pick(['x', 'y', 'px', 'py', 'fixed']));\r\n\r\n// Tag nodes w/ positions. Mutates the node map.\r\n// PositionTable -> {[key: State]: Node} -> void\r\nfunction setPositionTable(posTable, stateMap) {\r\n  _.forEach(function (node, state) {\r\n    var position = posTable[state];\r\n    if (position !== undefined) {\r\n      assign(node, position);\r\n    }\r\n  }, stateMap);\r\n}\r\n\r\n//TODO (stretchier goal) have the nodes remain in place when being renamed\r\nObject.defineProperty(StateViz.prototype, 'positionTable', {\r\n  get: function () { return getPositionTable(this.__stateMap); },\r\n  set: function (posTable) {\r\n    setPositionTable(posTable, this.__stateMap);\r\n    // ensure that a cooled layout will update\r\n    this.force.resume();\r\n  }\r\n});\r\n\r\n\r\nmodule.exports = StateViz;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/state-diagram/StateViz.js\n// module id = 14\n// module chunks = 0","module.exports = __webpack_public_path__ + \"state-diagram/StateViz.css\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/state-diagram/StateViz.css\n// module id = 15\n// module chunks = 0","'use strict';\r\n\r\nvar TM = require('./TuringMachine'),\r\n    jsyaml = require('js-yaml'),\r\n    _ = require('lodash');\r\n\r\n/**\r\n * Thrown when parsing a string that is valid as YAML but invalid\r\n * as a machine specification.\r\n *\r\n * Examples: unrecognized synonym, no start state defined,\r\n * transitioning to an undeclared state.\r\n *\r\n * A readable message is generated based on the details (if any) provided.\r\n * @param {string} reason  A readable error code.\r\n *   As an error code, this should be relatively short and not include runtime values.\r\n * @param {?Object} details Optional details. Possible keys:\r\n *                          problemValue, state, key, synonym, info, suggestion\r\n */\r\nfunction TMSpecError(reason, details) {\r\n  this.name = 'TMSpecError';\r\n  this.stack = (new Error()).stack;\r\n\r\n  this.reason = reason;\r\n  this.details = details || {};\r\n}\r\nTMSpecError.prototype = Object.create(Error.prototype);\r\nTMSpecError.prototype.constructor = TMSpecError;\r\n\r\n// generate a formatted description in HTML\r\nObject.defineProperty(TMSpecError.prototype, 'message', {\r\n  get: function () {\r\n    var header = this.reason;\r\n    var details = this.details;\r\n\r\n    function code(str) { return '<code>' + str + '</code>'; }\r\n    function showLoc(state, symbol, synonym) {\r\n      if (state != null) {\r\n        if (symbol != null) {\r\n          return ' in the transition from state ' + code(state) + ' and symbol ' + code(symbol);\r\n        } else {\r\n          return ' for state ' + code(state);\r\n        }\r\n      } else if (synonym != null) {\r\n        return ' in the definition of synonym ' + code(synonym);\r\n      }\r\n      return '';\r\n    }\r\n    var problemValue = details.problemValue ? ' ' + code(details.problemValue) : '';\r\n    var location = showLoc(details.state, details.symbol, details.synonym);\r\n    var sentences = ['<strong>' + header + problemValue + '</strong>' + location\r\n      , details.info, details.suggestion]\r\n      .filter(_.identity)\r\n      .map(function (s) { return s + '.'; });\r\n    if (location) { sentences.splice(1, 0, '<br>'); }\r\n    return sentences.join(' ');\r\n  },\r\n  enumerable: true\r\n});\r\n\r\n// type TransitionTable = {[key: string]: ?{[key: string]: string} }\r\n// type TMSpec = {blank: string, start state: string, table: TransitionTable}\r\n\r\n// IDEA: check with flow (flowtype.org)\r\n// throws YAMLException on YAML syntax error\r\n// throws TMSpecError for an invalid spec (eg. no start state, transitioning to an undefined state)\r\n// string -> TMSpec\r\nfunction parseSpec(str) {\r\n  var obj = jsyaml.safeLoad(str);\r\n  // check for required object properties.\r\n  // auto-convert .blank and 'start state' to string, for convenience.\r\n  if (obj == null) { throw new TMSpecError('The document is empty',\r\n    {info: 'Every Turing machine requires a <code>blank</code> tape symbol,' +\r\n    ' a <code>start state</code>, and a transition <code>table</code>'}); }\r\n  var detailsForBlank = {suggestion:\r\n    'Examples: <code>blank: \\' \\'</code>, <code>blank: \\'0\\'</code>'};\r\n  if (obj.blank == null) {\r\n    throw new TMSpecError('No blank symbol was specified', detailsForBlank);\r\n  }\r\n  obj.blank = String(obj.blank);\r\n  if (obj.blank.length !== 1) {\r\n    throw new TMSpecError('The blank symbol must be a string of length 1', detailsForBlank);\r\n  }\r\n  obj.startState = obj['start state'];\r\n  delete obj['start state'];\r\n  if (obj.startState == null) {\r\n    throw new TMSpecError('No start state was specified',\r\n    {suggestion: 'Assign one using <code>start state: </code>'});\r\n  }\r\n  obj.startState = String(obj.startState);\r\n  // parse synonyms and transition table\r\n  checkTableType(obj.table); // parseSynonyms assumes a table object\r\n  var synonyms = parseSynonyms(obj.synonyms, obj.table);\r\n  obj.table = parseTable(synonyms, obj.table);\r\n  // check for references to non-existent states\r\n  if (!(obj.startState in obj.table)) {\r\n    throw new TMSpecError('The start state has to be declared in the transition table');\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nfunction checkTableType(val) {\r\n  if (val == null) {\r\n    throw new TMSpecError('Missing transition table',\r\n    {suggestion: 'Specify one using <code>table:</code>'});\r\n  }\r\n  if (typeof val !== 'object') {\r\n    throw new TMSpecError('Transition table has an invalid type',\r\n      {problemValue: typeof val,\r\n        info: 'The transition table should be a nested mapping from states to symbols to instructions'});\r\n  }\r\n}\r\n\r\n// (any, Object) -> ?SynonymMap\r\nfunction parseSynonyms(val, table) {\r\n  if (val == null) {\r\n    return null;\r\n  }\r\n  if (typeof val !== 'object') {\r\n    throw new TMSpecError('Synonyms table has an invalid type',\r\n      {problemValue: typeof val,\r\n        info: 'Synonyms should be a mapping from string abbreviations to instructions'\r\n        + ' (e.g. <code>accept: {R: accept}</code>)'});\r\n  }\r\n  return _.mapValues(val, function (actionVal, key) {\r\n    try {\r\n      return parseInstruction(null, table, actionVal);\r\n    } catch (e) {\r\n      if (e instanceof TMSpecError) {\r\n        e.details.synonym = key;\r\n        if (e.reason === 'Unrecognized string') {\r\n          e.details.info = 'Note that a synonym cannot be defined using another synonym';\r\n        }\r\n      }\r\n      throw e;\r\n    }\r\n  });\r\n}\r\n\r\n// (?SynonymMap, {[key: string]: string}) -> TransitionTable\r\nfunction parseTable(synonyms, val) {\r\n  return _.mapValues(val, function (stateObj, state) {\r\n    if (stateObj == null) {\r\n      // case: halting state\r\n      return null;\r\n    }\r\n    if (typeof stateObj !== 'object') {\r\n      throw new TMSpecError('State entry has an invalid type',\r\n        {problemValue: typeof stateObj, state: state,\r\n          info: 'Each state should map symbols to instructions. An empty map signifies a halting state.'});\r\n    }\r\n    return _.mapValues(stateObj, function (actionVal, symbol) {\r\n      try {\r\n        return parseInstruction(synonyms, val, actionVal);\r\n      } catch (e) {\r\n        if (e instanceof TMSpecError) {\r\n          e.details.state = state;\r\n          e.details.symbol = symbol;\r\n        }\r\n        throw e;\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n// omits null/undefined properties\r\n// (?string, direction, ?string) -> {symbol?: string, move: direction, state?: string}\r\nfunction makeInstruction(symbol, move, state) {\r\n  return Object.freeze(_.omitBy({symbol: symbol, move: move, state: state},\r\n    function (x) { return x == null; }));\r\n}\r\n\r\nfunction checkTarget(table, instruct) {\r\n  if (instruct.state != null && !(instruct.state in table)) {\r\n    throw new TMSpecError('Undeclared state', {problemValue: instruct.state,\r\n      suggestion: 'Make sure to list all states in the transition table and define their transitions (if any)'});\r\n  }\r\n  return instruct;\r\n}\r\n\r\n// throws if the target state is undeclared (not in the table)\r\n// type SynonymMap = {[key: string]: TMAction}\r\n// (SynonymMap?, Object, string | Object) -> TMAction\r\nfunction parseInstruction(synonyms, table, val) {\r\n  return checkTarget(table, function () {\r\n    switch (typeof val) {\r\n      case 'string': return parseInstructionString(synonyms, val);\r\n      case 'object': return parseInstructionObject(val);\r\n      default: throw new TMSpecError('Invalid instruction type',\r\n        {problemValue: typeof val,\r\n          info: 'An instruction can be a string (a direction <code>L</code>/<code>R</code> or a synonym)'\r\n            + ' or a mapping (examples: <code>{R: accept}</code>, <code>{write: \\' \\', L: start}</code>)'});\r\n    }\r\n  }());\r\n}\r\n\r\nvar moveLeft = Object.freeze({move: TM.MoveHead.left});\r\nvar moveRight = Object.freeze({move: TM.MoveHead.right});\r\n\r\n// case: direction or synonym\r\nfunction parseInstructionString(synonyms, val) {\r\n  if (val === 'L') {\r\n    return moveLeft;\r\n  } else if (val === 'R') {\r\n    return moveRight;\r\n  }\r\n  // note: this order prevents overriding L/R in synonyms, as that would\r\n  // allow inconsistent notation, e.g. 'R' and {R: ..} being different.\r\n  if (synonyms && synonyms[val]) { return synonyms[val]; }\r\n  throw new TMSpecError('Unrecognized string',\r\n    {problemValue: val,\r\n      info: 'An instruction can be a string if it\\'s a synonym or a direction'});\r\n}\r\n\r\n// type ActionObj = {write?: any, L: ?string} | {write?: any, R: ?string}\r\n// case: ActionObj\r\nfunction parseInstructionObject(val) {\r\n  var symbol, move, state;\r\n  if (val == null) { throw new TMSpecError('Missing instruction'); }\r\n  // prevent typos: check for unrecognized keys\r\n  (function () {\r\n    var badKey;\r\n    if (!Object.keys(val).every(function (key) {\r\n      badKey = key;\r\n      return key === 'L' || key === 'R' || key === 'write';\r\n    })) {\r\n      throw new TMSpecError('Unrecognized key',\r\n        {problemValue: badKey,\r\n          info: 'An instruction always has a tape movement <code>L</code> or <code>R</code>, '\r\n        + 'and optionally can <code>write</code> a symbol'});\r\n    }\r\n  })();\r\n  // one L/R key is required, with optional state value\r\n  if ('L' in val && 'R' in val) {\r\n    throw new TMSpecError('Conflicting tape movements',\r\n    {info: 'Each instruction needs exactly one movement direction, but two were found'});\r\n  }\r\n  if ('L' in val) {\r\n    move = TM.MoveHead.left;\r\n    state = val.L;\r\n  } else if ('R' in val) {\r\n    move = TM.MoveHead.right;\r\n    state = val.R;\r\n  } else {\r\n    throw new TMSpecError('Missing movement direction');\r\n  }\r\n  // write key is optional, but must contain a char value if present\r\n  if ('write' in val) {\r\n    var writeStr = String(val.write);\r\n    if (writeStr.length === 1) {\r\n      symbol = writeStr;\r\n    } else {\r\n      throw new TMSpecError('Write requires a string of length 1');\r\n    }\r\n  }\r\n  return makeInstruction(symbol, move, state);\r\n}\r\n\r\nexports.TMSpecError = TMSpecError;\r\nexports.parseSpec = parseSpec;\r\n// re-exports\r\nexports.YAMLException = jsyaml.YAMLException;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/parser.js\n// module id = 16\n// module chunks = 0","'use strict';\n/**\n * Lightweight property assignment watching by overriding getters/setters.\n * Intended as a bridge between plain JS properties and other libraries.\n *\n * Inspired by https://gist.github.com/eligrey/384583, which works for\n * data properties only, this works for both data and accessor properties.\n *\n * 2015-11-21\n * @author Andy Li\n */\n\n/**\n * Watches a property for assignment by overriding it with a getter & setter\n * on top of the previous value or accessors.\n *\n * The handler can intercept assignments by returning a different value.\n * Watching an unwritable/unsettable property does nothing, but trying to watch\n * a non-existent or non-configurable property fails fast with TypeError.\n * @param  {!Object} thisArg The object that contains the property.\n * @param  {String}  prop    The name of the property to watch.\n * @param            handler The function to call when the property is\n *   assigned to. Important: this function intercepts assignment;\n *   its return value is set as the new value.\n * @throws {TypeError} if object is null or does not have the property\n * @throws {TypeError} if thisArg.prop is non-configurable\n * @return {?Object}         The previous property descriptor, or null if the\n *   property is not writable/settable.\n */\nfunction watch(thisArg, prop, handler) {\n  var desc = Object.getOwnPropertyDescriptor(thisArg, prop);\n  // check pre-conditions: existent, configurable, writable/settable\n  if (desc === undefined) {\n    throw new TypeError('Cannot watch nonexistent property \\''+prop+'\\'');\n  } else if (!desc.configurable) {\n    throw new TypeError('Cannot watch non-configurable property \\''+prop+'\\'');\n  } else if (!desc.writable && desc.set === undefined) {\n    return; // no-op since property can't change without reconfiguration\n  }\n\n  var accessors = (function () {\n    if (desc.set) {\n      // case: .get/.set\n      return {\n        get: desc.get,\n        set: function (newval) {\n          return desc.set.call(thisArg, handler.call(thisArg, prop, thisArg[prop], newval));\n        }\n      };\n    } else {\n      // case: .value\n      var val = desc.value;\n      return {\n        get: function () {\n          return val;\n        },\n        set: function (newval) {\n          return val = handler.call(thisArg, prop, val, newval);\n        }\n      };\n    }\n  })();\n  Object.defineProperty(thisArg, prop, accessors);\n\n  return desc;\n}\n\n/**\n * {@link watch} that, if successful, also calls the handler once with\n *   the current value (by setting it).\n * @see watch\n */\nfunction watchInit(thisArg, prop, handler) {\n  var value = thisArg[prop];\n  var desc = watch(thisArg, prop, handler);\n  if (desc) { thisArg[prop] = value; }\n  return desc;\n}\n\nif (typeof exports === 'object') {\n  exports.watch = watch;\n  exports.watchInit = watchInit;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/watch.js\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}